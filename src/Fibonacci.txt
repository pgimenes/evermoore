FIBONACCI IN ASSEMBLY:
R7=data stack register, R6=else part address, R5=1, R1=n,
R2=result of a fib()
Initializing:
0	LDI 0x100 		//X will be the initial address of the data stack
1	MOV R7 R0		//R7 = data stack register
2	LDI 14			//address, where the else part begins
3	MOV R6 R0		//R6 = holds the address, for cond jump 
4	INC R5			//R5=1, I’ll use this 1 often its cheaper this way
Main:
5	LDI n			//n is stored in R0
6	MOV R1 R0		//R1 = n
7	CALL 9			//call fib, store PC in separated stack register
8	STP			// R2 will hold the end result
Fib():-starts at line 9
if: 
9	MOV R4 R5 		//R4 = 1
10	SUB R4 R1		//R4 = 1-n, sets flags (cout doesn’t matter)
11	JMPC N R6 		//jumps to “else” if 1-n < 0; (=> n>1)  
12	MOV R2 R5		//R2 = 1
13	RTN			//return from function
else:
14	STORER R1 R7 		//save the current value of n for later
15	DEC R1 			//R1 = n-1, now we can call fib(n-1)
16	CALL 9			//calling fib(n-1), R2=fib(n-1)
17 	LOADR R1 RS		//reloading n to R1, fib(n-1) probably changed R1
18	MOV R3 R2		//R3=R2=fib(n-1), R2 will change to fib(n-2)
19	DEC R1			//R1 = n-1
20	DEC R1			//R1 = n-2 now we can call fib(n-2)
21	CALL fib()		//calling fib(n-2), R2=fib(n-2)
22	ADD R2 R3		//R2=R2+R3, R2=fib(n-2) + fib(n-1); overflow???
return y;
23	RTN			//return from function; R2=fib(n)
