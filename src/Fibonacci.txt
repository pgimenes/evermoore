FIBONACCI IN ASSEMBLY:
R7=data stack register, R6=else part address, R5=1, R1=n,
R2=result of a fib()
Initializing:
0	LDA 0x100 		//X will be the initial address of the data stack
1	MOV A R7 R0		//R7 = data stack register
2	LDI 14			//address, where the else part begins
3	MOV A R6 R0		//R6 = holds the address, for cond jump 
4	INC R5			//R5=1, I’ll use this 1 often its cheaper this way
_main:
5	LDA n			//n is stored in R0
6	MOV A R1 R0		//R1 = n
7	CALL 9			//call fib, store PC in separated stack register
8	STP			// R2 will hold the end result
_fib:-starts at line 9
if: 
9	MOV A R4 R5 		//R4 = 1
10	SUB A R4 R1		//R4 = 1-n, sets flags (cout doesn’t matter)
11	JMPC N R6 		//jumps to “else” if 1-n < 0; (=> n>1)  
12	MOV A R2 R5		//R2 = 1
13	RTN			//return from function
 else:
14	STORER A R1 R7 		//save the current value of n for later
15	DEC A R1 		//R1 = n-1, now we can call fib(n-1)
16	CALL 9			//calling fib(n-1), R2=fib(n-1)
17 	LOADR A R1 R7		//reloading n to R1, fib(n-1) probably changed R1
18	MOV A R3 R2		//R3=R2=fib(n-1), R2 will change to fib(n-2)
19	SIM A R1		//R1 = n-2 now we can call fib(n-2)
20	0x2			
21	CALL 9			//calling fib(n-2), R2=fib(n-2)
22	ADD A R2 R3		//R2=R2+R3, R2=fib(n-2) + fib(n-1); overflow???
 return y;
23	RTN			//return from function; R2=fib(n)
